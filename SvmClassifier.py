# -*- coding: utf-8 -*-
"""
Created on Fri Sep  4 16:52:01 2020

@author: Danish
"""

import collections
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import GridSearchCV
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from pickle import dump 
import os
import sys
from pickle import load

def load_model(ckpt_path):
    return load(open(ckpt_path, 'rb'))



class SVMClassifier:
    """
    Class which trains a linear SVM model, either using a given C or by performing a grid
    search over a range of C values and/or class weights.

    Parameters
    ----------
    C : TYPE
        DESCRIPTION.
    path : TYPE
        DESCRIPTION.
    name : TYPE, optional
        DESCRIPTION. The default is 'SVM.obj'.
    svc_linear : TYPE, optional
        DESCRIPTION. The default is True.
    weight : TYPE, optional
        DESCRIPTION. The default is None.

    Returns
    -------
    None.

    """
    def __init__(self, C, path, name='SVM.obj', svc_linear=True, weight=None):
        self.C = C
        self.path = path
        self.name = name
        self.svc_linear = svc_linear
        self.weight = weight
        self.clf = None
        self.type_C = None
        
    def __save_model(self, ckpt_path):
        dump(self, open(ckpt_path, 'wb'))
        
    def __PrintTrainConfig(self):
        print('\n\t\t\t\t____________________________________________')
        print('\t\t\t\t\t1. Type of Parameter C: '+self.type_C)
        print('\t\t\t\t\t1. Linear SVC: '+str(self.svc_linear))
        print('\t\t\t\t____________________________________________')
        ch = input('\n\nStart Training (y/N): ')
        if ch.lower() == 'y':
            pass
        elif ch.lower() == 'n':
            print('exit')
            sys.exit(0)

        
    def fit_svm_clf(self, X, Y):
        if self.path[-1] != '/':
            self.path += '/'
        os.makedirs(self.path, exist_ok=True)
        ckpt_path = self.path+self.name
        
        if np.isscalar(self.C):
            self.type_C = 'Scalar'
            self.__PrintTrainConfig()
            # Use the given C to train the classifier (no tuning of hyperparameter C)
            print('\nTraining Started!!')
            if self.svc_linear:
                self.clf = LinearSVC(C=self.C, penalty='l2', loss='hinge', max_iter=1e6, 
                                class_weight=self.weight, verbose=1)
            else:
                self.clf = SVC(C=self.C, kernel='linear', probability=True, max_iter=-1, 
                          class_weight=self.weight, verbose=True)
            self.clf.fit(X,Y)


        # Tune hyperparameter C over the given range of values
        elif isinstance(self.C, (collections.Sequence, np.ndarray)):
            self.type_C = 'Range of Values'
            self.__PrintTrainConfig()
            print('\nTraining Started!!')
            #setting the paramaters dictionary for parameter tuning
            params = {'C': self.C, 'class_weight': self.weight}
            if self.svc_linear:
                self.clf = LinearSVC(penalty='l2', loss='hinge', max_iter=1e6, verbose=1)
            else:
                self.clf = SVC(C=self.C, kernel='linear', max_iter=-1,  class_weight=self.weight, verbose=True)
    
            grid_clf = GridSearchCV(self.clf, params, cv=5, scoring='f1', n_jobs=-1, verbose=10).fit(X, Y)
            #getting the best classifier based on given C values.
            self.clf = grid_clf.best_estimator_
        #Dumping model to the disk
        self.__save_model(ckpt_path)
        print('\nTraining Completed!!')
        return self.clf
    
    def predict(self, X):
        """
        Perform classification on samples in X.

        Parameters
        ----------
        X : TYPE
            DESCRIPTION.

        Returns
        -------
        TYPE
            DESCRIPTION.

        """
        #return y predictions
        return self.clf.predict(X)
    
    def evaluate(self, X, Y, sample_weight=None):
        """
        Return the mean accuracy on the given test data and labels.

        Parameters
        ----------
        X : TYPE
            DESCRIPTION.
        Y : TYPE
            DESCRIPTION.
        sample_weight : TYPE
            DESCRIPTION.

        Returns
        -------
        TYPE
            DESCRIPTION.

        """
        acc = self.clf.score(X, Y, sample_weight)
        print('\nClassification Accuracy: {0:.4f}'.format(acc))
        return acc
    
    def __plot_confusion_matrix(self, data, labels, output_filename):
        """Plot confusion matrix using heatmap.
         
        Args:
            data (list of list): List of lists with confusion matrix data.
            labels (list): Labels which will be plotted across x and y axis.
            output_filename (str): Path to output file.
         
        """
        sns.set(color_codes=True)
        plt.figure(1, figsize=(9, 6))
        plt.title("Confusion Matrix")
        sns.set(font_scale=1.2)
        ax = sns.heatmap(data, annot=True, cmap=plt.cm.Blues, cbar_kws={'label': 'Scale'})
        ax.set_xticklabels(labels)
        ax.set_yticklabels(labels)
        ax.set(ylabel="True Label", xlabel="Predicted Label")
        plt.savefig(output_filename, bbox_inches='tight', dpi=300)
        plt.show()
        plt.close()
        
        
    def __get_acc(self, X, Y, labels):
        #Making predictions
        Y_pred = self.predict(X)
        #Computing Accuracy
        acc = accuracy_score(Y, Y_pred)
        print('\nClassification Accuracy: {0:.4f}'.format(acc))
        #Getting Classification Report
        keys = list(labels.keys())
        values =list(labels.values())
        report = classification_report(Y, Y_pred, labels=keys, target_names=values)
        print("\nClassification Report:\n", report)
        return Y_pred, acc, values
        
    def visualize_evaluation(self, X, Y, labels, normalize=None, save=True, path=None):
        """
        

        Parameters
        ----------
        X : TYPE
            DESCRIPTION.
        Y : TYPE
            DESCRIPTION.
        labels : TYPE
            DESCRIPTION.
        normalize : {‘true’, ‘pred’, ‘all’}, optional
            Normalizes confusion matrix over the true (rows), predicted (columns) conditions or 
            all the population. If None, confusion matrix will not be normalized. The default 
            is None.
        save : TYPE, optional
            DESCRIPTION. The default is True.
        path : TYPE, optional
            DESCRIPTION. The default is None.

        Raises
        ------
        ValueError
            DESCRIPTION.

        Returns
        -------
        None.

        """
        if save and path==None:
            raise ValueError('Invalid value given to `path`, `path` can not be `None` when `save` is True')
        #Evaluate and print report of classification
        Y_pred, acc, values = self.__get_acc(X, Y, labels)
        #Get and plot Confusion matrix
        cm = confusion_matrix(Y, Y_pred, normalize=normalize)
        if '.png' not in path:
            path += '.png'
        self.__plot_confusion_matrix(cm, values, path)
        return acc
        
    
    
    
    
        
        
        










