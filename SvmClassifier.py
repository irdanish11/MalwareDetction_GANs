# -*- coding: utf-8 -*-
"""
Created on Fri Sep  4 16:52:01 2020

@author: Danish
"""

import collections
import numpy as np
from sklearn.model_selection import GridSearchCV
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.metrics import classification_report 
from pickle import dump, load 
from utilities import plot_confusion_matrix
import os
import sys


def load_model(ckpt_path):
    return load(open(ckpt_path, 'rb'))



class SVMClassifier:
    """
    Class which trains a linear SVM model, either using a given C or by performing a grid
    search over a range of C values and/or class weights.

    Parameters
    ----------
    C : TYPE
        DESCRIPTION.
    path : TYPE
        DESCRIPTION.
    name : TYPE, optional
        DESCRIPTION. The default is 'SVM.obj'.
    svc_linear : TYPE, optional
        DESCRIPTION. The default is True.
    weight : TYPE, optional
        DESCRIPTION. The default is None.

    Returns
    -------
    None.

    """
    def __init__(self, C, path, name='SVM.obj', svc_linear=True, weight=None):
        self.C = C
        self.path = path
        self.name = name
        self.svc_linear = svc_linear
        self.weight = weight
        self.classifier = None
        self.type_C = None
        
    def __save_model(self, ckpt_path):
        dump(self, open(ckpt_path, 'wb'))
        
    def __PrintTrainConfig(self):
        print('\n\t\t\t\t____________________________________________')
        print('\t\t\t\t\t1. Type of Parameter C: '+self.type_C)
        print('\t\t\t\t\t2. Linear SVC: '+str(self.svc_linear))
        print('\t\t\t\t____________________________________________')
        ch = input('\n\nStart Training of SVM (y/N): ')
        if ch.lower() == 'y':
            pass
        elif ch.lower() == 'n':
            print('exit')
            sys.exit(0)

        
    def fit_svm_classifier(self, X, Y):
        if self.path[-1] != '/':
            self.path += '/'
        os.makedirs(self.path, exist_ok=True)
        ckpt_path = self.path+self.name
        
        if np.isscalar(self.C):
            self.type_C = 'Scalar'
            self.__PrintTrainConfig()
            # Use the given C to train the classifier (no tuning of hyperparameter C)
            print('\nSVM Training Started!!')
            if self.svc_linear:
                self.classifier = LinearSVC(C=self.C, penalty='l2', loss='hinge', max_iter=1e6, 
                                class_weight=self.weight, verbose=1)
            else:
                self.classifier = SVC(C=self.C, kernel='linear', probability=True, max_iter=-1, 
                          class_weight=self.weight, verbose=True)
            self.classifier.fit(X,Y)


        # Tune hyperparameter C over the given range of values
        elif isinstance(self.C, (collections.Sequence, np.ndarray)):
            self.type_C = 'Range of Values'
            self.__PrintTrainConfig()
            print('\nTraining Started!!')
            #setting the paramaters dictionary for parameter tuning
            params = {'C': self.C, 'class_weight': self.weight}
            if self.svc_linear:
                self.classifier = LinearSVC(penalty='l2', loss='hinge', max_iter=1e6, verbose=1)
            else:
                self.classifier = SVC(C=self.C, kernel='linear', max_iter=-1,  class_weight=self.weight, verbose=True)
    
            grid_classifier = GridSearchCV(self.classifier, params, cv=5, scoring='f1', n_jobs=-1, verbose=10).fit(X, Y)
            #getting the best classifier based on given C values.
            self.classifier = grid_classifier.best_estimator_
        #Dumping model to the disk
        self.__save_model(ckpt_path)
        print('\nSVM Training Completed!!')
        return self.classifier
    
    def predict(self, X):
        """
        Perform classification on samples in X.

        Parameters
        ----------
        X : TYPE
            DESCRIPTION.

        Returns
        -------
        TYPE
            DESCRIPTION.

        """
        #return y predictions
        return self.classifier.predict(X)
    
    def evaluate(self, X, Y, sample_weight=None):
        """
        Return the mean accuracy on the given test data and labels.

        Parameters
        ----------
        X : TYPE
            DESCRIPTION.
        Y : TYPE
            DESCRIPTION.
        sample_weight : TYPE
            DESCRIPTION.

        Returns
        -------
        TYPE
            DESCRIPTION.

        """
        acc = self.classifier.score(X, Y, sample_weight)
        print('\nClassification Accuracy: {0:.4f}'.format(acc))
        return acc
        
    def __get_acc(self, X, Y, labels):
        #Making predictions
        Y_pred = self.predict(X)
        #Computing Accuracy
        acc = accuracy_score(Y, Y_pred)
        print('\nSVM Classification Accuracy: {0:.4f}'.format(acc))
        #Getting Classification Report
        keys = list(labels.keys())
        values =list(labels.values())
        report = classification_report(Y, Y_pred, labels=keys, target_names=values)
        print("\nSVM Classification Report:\n", report)
        return Y_pred, acc, values
        
    def visualize_evaluation(self, X, Y, labels, title, normalize=None, save=True, path=None):
        """
        

        Parameters
        ----------
        X : TYPE
            DESCRIPTION.
        Y : TYPE
            DESCRIPTION.
        labels : TYPE
            DESCRIPTION.
        normalize : {‘true’, ‘pred’, ‘all’}, optional
            Normalizes confusion matrix over the true (rows), predicted (columns) conditions or 
            all the population. If None, confusion matrix will not be normalized. The default 
            is None.
        save : TYPE, optional
            DESCRIPTION. The default is True.
        path : TYPE, optional
            DESCRIPTION. The default is None.

        Raises
        ------
        ValueError
            DESCRIPTION.

        Returns
        -------
        None.

        """
        if save and path==None:
            raise ValueError('Invalid value given to `path`, `path` can not be `None` when `save` is True')
        #Evaluate and print report of classification
        Y_pred, acc, values = self.__get_acc(X, Y, labels)
        #Get and plot Confusion matrix
        cm_n = confusion_matrix(Y, Y_pred, normalize=normalize)
        cm = confusion_matrix(Y, Y_pred)
        if '.png' not in path:
            path += '.png'
        path_n = path.split('.png')[0]+'_Normalised.png'
        plot_confusion_matrix(cm, values, path, title)
        plot_confusion_matrix(cm_n, values, path_n, title)
        return acc
        
    
    
    
    
        
        
        










