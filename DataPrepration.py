# -*- coding: utf-8 -*-
"""
Created on Tue Sep  1 23:21:41 2020

@author: Danish
"""


import json
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction import DictVectorizer
from sklearn.feature_selection import SelectKBest, chi2, mutual_info_classif
import pickle
import os
from scipy.sparse import vstack


def ReadJSON(path):
    print('Reading Json file from path: <'+path+'>')
    with open(path, 'r') as f:
        obj = json.load(f)
    return obj

def remove_signatures(X,Y):
    for dic in X:
        del dic['sha256']
    Y_ = []
    for val in Y:
        Y_.append(val[0])
    return X, Y_

def feature_selector(X, Y, vectorizer, n_features):
    if type(n_features)==None:
        raise TypeError('n_features argument can not be None, when feature_selection set to True.')
    selector = SelectKBest(chi2, k=n_features).fit(X, Y)
    vectorizer.restrict(selector.get_support())
    X = selector.transform(X)
    print('Shape of X after Feature Selection: ', X.shape)
    return X

def get_classified_data(X, Y):
    #Separating Malware and Benignware
    indicies_malware = np.where(Y == 1)[0]
    X_malware = X[indicies_malware, :]
    indicies_benignware = np.where(Y == 0)[0]
    X_benignware = X[indicies_benignware, :]
    #Y Data
    Y_malware = np.ones(X_malware.shape[0])
    Y_benignware = np.zeros(X_benignware.shape[0])
    return X_malware, X_benignware, Y_malware, Y_benignware

def dump_data(obj, path, f_name, save=True):
    os.makedirs(path, exist_ok=True)
    lst = ['X', 'Y', 'X_Malware', 'X_Benignware', 'Y_Malware', 'Y_Benignware', 'feature_names']
    dic = {}
    for idx, item in enumerate(obj):
        dic[lst[idx]] = item
    #pickling the dictionary
    if save:
        with open(path+f_name, 'wb') as f:
            pickle.dump(dic, f)
    return dic
    

def sparser(X, Y, path, f_name, feature_selection, n_features, save):
    vectorizer = DictVectorizer(sparse=True, dtype=np.uint8)
    X = vectorizer.fit_transform(X)
    #converting Y to array
    if type(Y)!=np.ndarray:
        if type(Y)!= list:
            raise TypeError('Type of Y must be list or numpy.ndarray')
        Y = np.array(Y, dtype=np.uint8)
    print('\nShape of X: ', X.shape)
    print('Shape of Y: ', Y.shape)
    if feature_selection:
        X = feature_selector(X, Y, vectorizer, n_features)
    #Names of the features
    feature_names = vectorizer.feature_names_
    X_malware, X_benignware, Y_malware, Y_benignware = get_classified_data(X, Y)
    dump = (X, Y, X_malware, X_benignware, Y_malware, Y_benignware, feature_names)
    
    dic = dump_data(dump, path, f_name, save)
    return dic


def data_selector(ret_dic, dic, test_size, choice, verbose=True):
    if choice in [1,2,3]:
        key = ret_dic[choice]
        if verbose:
            print('\nReturning the Data of: {0}'.format(key))
            print('___________________________________________________________________________')
        return dic[key[0]], dic[key[1]]
    elif choice in [4,5]:
        key = ret_dic[choice]
        if verbose:
            print('\nReturning X_train, X_test, Y_train, Y_test, of {0} data.'.format(key[0]))
            print('___________________________________________________________________________')
        X = dic['X_'+key[0]]
        Y = dic['Y_'+key[0]]
        X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, 
                                                            random_state=0)
        if verbose:
            print('\nShape of {0} X_train: '.format(key[0])+str(X_train.shape))
            print('Shape of {0} Y_train: '.format(key[0])+str(Y_train.shape))
            print('Shape of {0} X_test: '.format(key[0])+str(X_test.shape))
            print('Shape of {0} Y_test: '.format(key[0])+str(Y_test.shape)+'\n')
        return X_train, X_test, Y_train, Y_test
    elif choice==6:
        if verbose:
            print('\nReturning Feature Names as a list.')
            print('___________________________________________________________________________')
        return dic['feature_names']



def Get_Data(pathX, pathY, feature_selection=False, n_features=None, test_size=0.25, choice=None, verbose=True, save=True, new=False):
    """
		Enter 1 For X & Y
		Enter 2 For X_Malware & Y_Malware
		Enter 3 For X_Benignware & Y_Benignware
		Enter 4 For Malware Train & Test
		Enter 5 For Benignware Train & Test
		Enter 6 For Feature Names

    Parameters
    ----------
    pathX : TYPE
        DESCRIPTION.
    pathY : TYPE
        DESCRIPTION.
    feature_selection : TYPE, optional
        DESCRIPTION. The default is False.
    n_features : TYPE, optional
        DESCRIPTION. The default is None.
    test_size : TYPE, optional
        DESCRIPTION. The default is 0.25.

    Returns
    -------
    TYPE
        DESCRIPTION.

    """
    if verbose:
        print('___________________________________________________________________________')
    path='./Data/'
    f_name='Parsed.obj'
    if os.path.exists(path+f_name) and not new:
        if verbose:
            print('Existing Processed Data Found in the directory: <{0}>. \nLoading the data!!!'.format(path+f_name))
        with open(path+f_name, 'rb') as f:
            dic = pickle.load(f)
    elif new:
        if verbose:
            print('No Existing Processed Data Found in the directory: <{0}>. \nData Processing will be performed from Json loaded Data!!!\n'.format(path+f_name))
        #Read the data from JSON and process it.
        X = ReadJSON(pathX)
        Y = ReadJSON(pathY)
        #Remove Signatures
        X,Y = remove_signatures(X,Y)
        #Converting from DENSE to CSR Sparse Matrix
        dic = sparser(X, Y, path, f_name, feature_selection, n_features, save)
    ret_dic = {1:['X', 'Y'], 2:['X_Malware', 'Y_Malware'], 3: ['X_Benignware', 'Y_Benignware'],
               4:['Malware', 'Train & Test'], 5:['Benignware', 'Train & Test'], 6:['Feature', 'Names']}
    return data_selector(ret_dic, dic, test_size, choice, verbose)
        
def data_joiner(benignware_train_test, malware_train_test, data='train'):
    """
    

    Parameters
    ----------
    benignware_train_test : TYPE
        DESCRIPTION.
    malware_train_test : TYPE
        DESCRIPTION.
    data : ['train', test], optional
        DESCRIPTION. The default is 'train'.

    Returns
    -------
    None.

    """
    if data=='train':
        X = vstack([benignware_train_test[0],malware_train_test[0]])
        Y = np.concatenate((benignware_train_test[2],malware_train_test[2]))
        print('Shape of X_train: '+str(X.shape))
        print('Shape of Y_train: '+str(Y.shape))
    elif data=='test':
        X = vstack([benignware_train_test[1],malware_train_test[1]])
        Y = np.concatenate((benignware_train_test[3],malware_train_test[3]))
        print('Shape of X_test: '+str(X.shape))
        print('Shape of Y_test: '+str(Y.shape))
    return X, Y

def prepare_GanData(pathX, pathY, save_path, f_name='GANs_Data.obj', feature_selection=True, n_features=15000, test_size=0.25): 
    print('\n')
    X, Y = Get_Data(pathX, pathY, feature_selection, n_features, test_size, choice=1, verbose=False, new=True)
    print('\n___________________________________________________________________________')
    print('Preparing Data for GANs\n')
    #Preparing Training DATA
    X_malware, Y_malware = Get_Data(pathX, pathY, choice=2, verbose=False)
    X_benignware, Y_benignware = Get_Data(pathX, pathY, choice=3, verbose=False)
    X_train = (X_benignware, X_malware)
    print('Shape of X_train, Benignware & Malware Respectively: '+str(X_train[0].shape)+' & '+str(X_train[1].shape))
    #Preparing test Data
    malware_train_test = Get_Data(pathX, pathY, choice=4, verbose=False)
    benignware_train_test = Get_Data(pathX, pathY, choice=5, verbose=False)
    X_test = (benignware_train_test[1],malware_train_test[1])
    print('Shape of X_test, Benignware & Malware Respectively: '+str(X_test[0].shape)+' & '+str(X_test[1].shape))
    feature_names = Get_Data(pathX, pathY, choice=6, verbose=False)
    print('Shape of feature names list: '+str(len(feature_names)))
    dic = {'X_train':X_train, 'X_test':X_test, 'feature_names':feature_names}
    if save_path[-1] != '/':
        save_path += '/'
    os.makedirs(save_path, exist_ok=True)
    with open(save_path+f_name, 'wb') as f:
            pickle.dump(dic, f)
    print('\nData Prepared for GANs & Stored on Disk Sucessfully!')
    print('___________________________________________________________________________\n')
    return dic

def load_GanData(save_path, f_name='GANs_Data.obj'):
    print('\n___________________________________________________________________________')
    if not os.path.exists(save_path+f_name):
        raise NotImplementedError('No Existing Data Found at the path: <{0}> .\n Please Select Prepare GANs Data, or Call prepare_GanData() on the Json files.'.format(save_path+f_name))
    
    print('Loading Data for GANs\n')
    if save_path[-1] != '/':
        save_path += '/'
    with open(save_path+f_name, 'rb') as f:
            dic = pickle.load(f)
    X_train = dic['X_train']
    X_test = dic['X_test']
    feature_names = dic['feature_names']
    print('Shape of X_train, Benignware & Malware Respectively: '+str(X_train[0].shape)+' & '+str(X_train[1].shape))
    print('Shape of X_test, Benignware & Malware Respectively: '+str(X_test[0].shape)+' & '+str(X_test[1].shape))
    print('Shape of feature names list: '+str(len(feature_names)))
    print('\nSuccessfully Loaded the Data for GANs!')
    print('___________________________________________________________________________\n')
    return X_train, X_test, feature_names

def prepare_SvmData(pathX, pathY, save_path, f_name='SVM_Data.obj', feature_selection=False, n_features=15000, test_size=0.25): 
    print('\n')
    X, Y = Get_Data(pathX, pathY, feature_selection, n_features, test_size, choice=1, verbose=False, new=True)
    print('\n___________________________________________________________________________')
    print('Preparing Data for SVM Model\n')
    #Preparing training & testing Data
    malware_train_test = Get_Data(pathX, pathY, choice=4, verbose=False)
    benignware_train_test = Get_Data(pathX, pathY, choice=5, verbose=False)
    #getting Training Data
    X_train, Y_train = data_joiner(benignware_train_test, malware_train_test, data='train')
    #getting Test Data
    X_test, Y_test = data_joiner(benignware_train_test, malware_train_test, data='test')
    #preparing dictionary
    dic = {'X_train':X_train, 'Y_train':Y_train, 'X_test':X_test, 'Y_test':Y_test}
    if save_path[-1] != '/':
        save_path += '/'
    os.makedirs(save_path, exist_ok=True)
    with open(save_path+f_name, 'wb') as f:
            pickle.dump(dic, f)
    print('\nData Prepared for SVM Model & Stored on Disk Sucessfully!')
    print('___________________________________________________________________________\n')
    return dic

def load_SvmData(save_path, f_name='SVM_Data.obj'):
    print('\n___________________________________________________________________________')
    if not os.path.exists(save_path+f_name):
        raise NotImplementedError('No Existing Data Found at the path: <{0}> .\n Please Select Prepare SVM Data, or Call prepare_SvmData() on the Json files.'.format(save_path+f_name))
    
    print('Loading Data for SVM\n')
    if save_path[-1] != '/':
        save_path += '/'
    with open(save_path+f_name, 'rb') as f:
            dic = pickle.load(f)
    X_train = dic['X_train']
    Y_train = dic['Y_train']
    X_test = dic['X_test']
    Y_test = dic['Y_test']
    print('Shape of X_train: '+str(X_train.shape))
    print('Shape of Y_train: '+str(Y_train.shape))
    print('Shape of X_test: '+str(X_test.shape))
    print('Shape of Y_test: '+str(Y_test.shape))
    print('\nSuccessfully Loaded the Data for SVM!')
    print('___________________________________________________________________________\n')
    return X_train, Y_train, X_test, Y_test
    
    
    

    

if __name__=='__main__':
    ################# Data Prepration #################
    pathX = './Data/drebin-features/drebin-parrot-v2-down-features-X.json'
    pathY = './Data/drebin-features/drebin-parrot-v2-down-features-Y.json'
