# -*- coding: utf-8 -*-
"""
Created on Tue Sep  1 23:21:41 2020

@author: Danish
"""


import json
from tqdm import tqdm
import numpy as np
import shelve
import numpy as np
import scipy as sp
from numpy import ones, zeros
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction import DictVectorizer
from sklearn.feature_selection import SelectKBest, chi2, mutual_info_classif
import time
import pickle
import os

def ReadJSON(path):
    print('\nReading Json file from path: <'+path+'>')
    with open(path, 'r') as f:
        obj = json.load(f)
    return obj

def remove_signatures(X,Y):
    for dic in X:
        del dic['sha256']
    Y_ = []
    for val in Y:
        Y_.append(val[0])
    return X, Y_

def feature_selector(X, Y, vectorizer, n_features):
    if type(n_features)==None:
        raise TypeError('n_features argument can not be None, when feature_selection set to True.')
    selector = SelectKBest(chi2, k=n_features).fit(X, Y)
    vectorizer.restrict(selector.get_support())
    X = selector.transform(X)
    print('Shape of X after Feature Selection: ', X.shape)
    return X

def get_classified_data(X, Y):
    #Separating Malware and Goodware
    indicies_malware = np.where(Y == 1)[0]
    X_malware = X[indicies_malware, :]
    indicies_goodware = np.where(Y == 0)[0]
    X_goodware = X[indicies_goodware, :]
    #Y Data
    Y_malware = np.ones(X_malware.shape[0])
    Y_goodware = np.zeros(X_goodware.shape[0])
    return X_malware, X_goodware, Y_malware, Y_goodware

def dump_data(obj, path, f_name):
    os.makedirs(path, exist_ok=True)
    lst = ['X', 'Y', 'X_Malware', 'X_Goodware', 'Y_Malware', 'Y_Goodware', 'feature_names']
    dic = {}
    for idx, item in enumerate(obj):
        dic[lst[idx]] = item
    #pickling the dictionary
    with open(path+f_name, 'wb') as f:
        pickle.dump(dic, f)
    return dic
    

def sparser(X, Y, path, f_name, feature_selection, n_features):
    vectorizer = DictVectorizer(sparse=True, dtype=np.uint8)
    X = vectorizer.fit_transform(X)
    #converting Y to array
    if type(Y)!=np.ndarray:
        if type(Y)!= list:
            raise TypeError('Type of Y must be list or numpy.ndarray')
        Y = np.array(Y, dtype=np.uint8)
    print('\nShape of X: ', X.shape)
    print('Shape of Y: ', Y.shape)
    if feature_selection:
        X = feature_selector(X, Y, vectorizer, n_features)
    #Names of the features
    feature_names = vectorizer.feature_names_
    X_malware, X_goodware, Y_malware, Y_goodware = get_classified_data(X, Y)
    dump = (X, Y, X_malware, X_goodware, Y_malware, Y_goodware, feature_names)
    dic = dump_data(dump, path, f_name)
    return dic


def data_selector(ret_dic, dic, test_size):
    print('\nChoose the Option!\n')
    for i, val in enumerate(list(ret_dic.values())):
        idx = i+1
        if idx in [1,2,3]:
            print('\t\tEnter ' + str(idx) + ' For ' + ret_dic[idx][0] + ' & ' + ret_dic[idx][1])
        else:
            print('\t\tEnter ' + str(idx) + ' For ' + ret_dic[idx][0] + ' ' + ret_dic[idx][1])
    choice = int(input('Enter Your choice between 1 & 6: '))
    if choice in [1,2,3]:
        key = ret_dic[choice]
        print('\nReturning the Data of: {0}'.format(key))
        print('___________________________________________________________________________')
        return dic[key[0]], dic[key[1]]
    elif choice in [4,5]:
        key = ret_dic[choice]
        print('\nReturning X_train, X_test, Y_train, Y_test, of {0} data.'.format(key[0]))
        print('___________________________________________________________________________')
        X = dic['X_'+key[0]]
        Y = dic['Y_'+key[0]]
        X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, 
                                                            random_state=0)
        print('\nSahpe of {0} X_train: '.format(key[0])+str(X_train.shape))
        print('Sahpe of {0} Y_train: '.format(key[0])+str(Y_train.shape))
        print('Sahpe of {0} X_test: '.format(key[0])+str(X_test.shape))
        print('Sahpe of {0} Y_test: '.format(key[0])+str(Y_test.shape)+'\n')
        return X_train, X_test, Y_train, Y_test
    elif choice==6:
        print('\nReturning Feature Names as a list.')
        print('___________________________________________________________________________')
        return dic['feature_names']



def Get_Data(pathX, pathY, feature_selection=False, n_features=None, test_size=0.3):
    print('___________________________________________________________________________')
    path='./Data/'
    f_name='Parsed.obj'
    if os.path.exists(path+f_name):
        print('Existing Processed Data Found in the directory: <{0}>. \nLoading the data!!!'.format(path+f_name))
        with open(path+f_name, 'rb') as f:
            dic = pickle.load(f)
    else:
        print('No Existing Processed Data Found in the directory: <{0}>. \nData Processing will be performed from Json loaded Data!!!\n'.format(path+f_name))
        #Read the data from JSON and process it.
        X = ReadJSON(pathX)
        Y = ReadJSON(pathY)
        #Remove Signatures
        X,Y = remove_signatures(X,Y)
        #Converting from DENSE to CSR Sparse Matrix
        dic = sparser(X, Y, path, f_name, feature_selection, n_features)
    ret_dic = {1:['X', 'Y'], 2:['X_Malware', 'Y_Malware'], 3: ['X_Goodware', 'Y_Goodware'],
               4:['Malware', 'Train & Test'], 5:['Goodware', 'Train & Test'], 6:['Feature', 'Names']}
    return data_selector(ret_dic, dic, test_size)
        

pathX = 'drebin-features/drebin-parrot-v2-down-features-X.json'
pathY = 'drebin-features/drebin-parrot-v2-down-features-Y.json'

X, Y = Get_Data(pathX, pathY, feature_selection=False, n_features=None, test_size=0.3)

X_malware, Y_malware = Get_Data(pathX, pathY)

X_goodware, Y_goodware = Get_Data(pathX, pathY)

malware_train_test = Get_Data(pathX, pathY)

goodware_train_test = Get_Data(pathX, pathY)

feature_names = Get_Data(pathX, pathY)
