# -*- coding: utf-8 -*-
"""
Created on Wed Sep  2 17:43:44 2020

@author: Danish
"""


import json
from tqdm import tqdm
import numpy as np
from DataPrepration import remove_signatures
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import os

path='./Data/Plots/'
os.makedirs(path, exist_ok=True)


def ReadJSON(path):
    with open(path, 'r') as f:
        obj = json.load(f)
    return obj


def high_level_features(X):    
    f_len = []
    unique = []    
    for i in tqdm(X):
        f_len.append(len(i))
        for f in list(i.keys()):
            if f.split(':')[0] not in unique:
                unique.append(f.split(':')[0])
    return unique, f_len

def non_common(dic1, dic2, common=False):
    dic3 = {}
    if not common:
        for f in dic1:
            if f not in dic2: 
                dic3[f] = dic1[f]
    elif common:
        for f in dic1:
            if f in dic2: 
                dic3[f] = dic1[f]
    return dic3

def get_features_info(X, Y):
    info = {}
    features_count = {}
    malware_feature_count = {}
    benignware_feature_count = {}
    catogeories_count = {}
    for val in unique:
        #[Benignware, Malware]
        catogeories_count[val] = [0, 0]
        
    for idx, dic in tqdm(enumerate(X)):
        label = Y[idx]
        for f in dic:
            #finding category
            category = f.split(':')[0]
            #categories count
            catogeories_count[category][label] += 1
            #Counting features
            if f not in features_count:
                features_count[f] = 1
            else:
                features_count[f] += 1
            #Benignware Count
            if label==0:
                if f not in benignware_feature_count:
                    benignware_feature_count[f] = 1
                else:
                    benignware_feature_count[f] += 1 
            #Malware Count
            if label==1:
                if f not in malware_feature_count:
                    malware_feature_count[f] = 1
                else:
                    malware_feature_count[f] += 1
    benignware_feature_only = non_common(benignware_feature_count, malware_feature_count)  
    malware_feature_only = non_common(malware_feature_count, benignware_feature_count)       
    common_features = non_common(benignware_feature_count, malware_feature_count, common=True)    
    
    info['features_count'] = features_count
    info['malware_feature_count'] = malware_feature_count
    info['benignware_feature_count'] = benignware_feature_count
    info['catogeories_count'] = catogeories_count
    info['benignware_feature_only'] = benignware_feature_only
    info['malware_feature_only'] = malware_feature_only
    info['common_features'] = common_features
    return info

def get_distribution(count):
    max_val = str(max(count))
    dist = {'1':[], '2-10':[], '11-100':[], '101-'+max_val:[]}
    for val in count:
        if val==1:
            dist['1'].append(val)
        elif val>=2 and val<=10:
            dist['2-10'].append(val)
        elif val>10 and val<=100:
            dist['11-100'].append(val)
        else:
            dist['101-'+max_val].append(val)
            dist_size = []
    for v in list(dist.values()):
        dist_size.append(len(v))
    return dist, dist_size



def pie_plot(data, labels, title, title2, r=1.2, save=True, fmt='%1.1f%%'):
    def my_fmt(x):
        print(x)
        return '{:.1f}%\n({:.0f})'.format(x, sum(data)*x/100)
    if fmt == 'my_fmt':
        fmt=my_fmt
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    ax.axis('equal')
    #
    wedges, texts, autotexts = ax.pie(data, labels=labels, autopct=fmt,
                                      radius=r, pctdistance=0.85)
    ax.legend(wedges, labels, title=title2, loc="upper left",
              bbox_to_anchor=(1, 0, 0.5, 1))
    plt.setp(autotexts, size=8, weight="bold")
    ax.set_title(title, loc='left')
    if save:
        plt.savefig(path+title+'.png', bbox_inches='tight', dpi=300)
    plt.show()
    plt.close()
    
def grouped_bar_plot(d1, d2, labels, lb, title, y_label, save=True):
    x = np.arange(len(labels))  # the label locations
    width = 0.35  # the width of the bars
    fig, ax = plt.subplots()
    rects1 = ax.bar(x - width/2, d1, width, label=lb[0])
    rects2 = ax.bar(x + width/2, d2, width, label=lb[1])
    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_ylabel(y_label)
    ax.set_title(title)
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.set_ylim(0,5500000)
    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
             rotation_mode="anchor")
    ax.legend()
    def autolabel(rects):
        """Attach a text label above each bar in *rects*, displaying its height."""
        for rect in rects:
            height = rect.get_height()
            ax.annotate('{}'.format(height),
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom')
    autolabel(rects1)
    autolabel(rects2)
    fig.tight_layout()
    if save:
        plt.savefig(path+title+'.png', bbox_inches='tight', dpi=300)
    plt.show()
    plt.close()

def fil(length, val):
    col = []
    for i in range(length):
       col.append(val)
    return col

def compute_stats(arrays, classes):
    mean = []; min_ = []
    max_ = []; std = []
    for arr in arrays:
        mean.append(np.mean(arr))
        min_.append(min(arr))
        max_.append(max(arr))
        std.append(np.std(arr))
    for idx, clas in enumerate(classes):
        print('\n___________________________________________________________')
        print('\nStats for {0}: '.format(clas))
        print('\t\tMean: {0:.1f}'.format(mean[idx]))
        print('\t\tStandard Deviation: {0:.1f}'.format(std[idx]))
        print('\t\tMaximum Value: {0}'.format(max_[idx]))
        print('\t\tMinimum Value: {0}'.format(min_[idx]))
        print('___________________________________________________________')
    return np.array(mean), np.array(min_), np.array(max_), np.array(std)

def get_box_plot(data, title, save=True):
    #Plotting box plot
    sns.set_style("whitegrid")
    box_plot = sns.boxplot(x='Class', y='Features', data=df, palette='Set3')
    box_plot.set_title(title)
    
    #Adding Mean values to the plot
    means = df.groupby(['Class'])['Features'].mean()
    means = means.round(decimals=1)
    vertical_offset = df['Features'].mean() * 0.05 # offset from median for display
    for xtick in box_plot.get_xticks():
        box_plot.text(xtick,means[xtick] + vertical_offset,means[xtick], 
                horizontalalignment='center',size='x-large',color='k',weight='semibold')
    
    #Adding maxes values to the plot
    maxes = df.groupby(['Class'])['Features'].max()
    vertical_offset = df['Features'].max() * 0.05 # offset from median for display
    for xtick in box_plot.get_xticks():
        box_plot.text(xtick,maxes[xtick] + vertical_offset,maxes[xtick], 
                horizontalalignment='center',size='large',color='k',weight='semibold')
    #Adding mins values to the plot
    mins = df.groupby(['Class'])['Features'].min()
    vertical_offset = df['Features'].min() - 400 # offset from median for display
    for xtick in box_plot.get_xticks():
        box_plot.text(xtick,mins[xtick] + vertical_offset,mins[xtick], 
                horizontalalignment='right',size='large',color='k',weight='semibold')    
    #finalizing plot
    box_plot.set_ylim(-500,7500)
    if save:
        box_plot.figure.savefig(path+title+'.png', bbox_inches='tight', dpi=300)
    plt.show()
    plt.close()
###################### Scripting Below #######################
if __name__=='__main__':
    pathX = './Data/drebin-features/drebin-parrot-v2-down-features-X.json'
    pathY = './Data/drebin-features/drebin-parrot-v2-down-features-Y.json'
    #Read Data
    X = ReadJSON(pathX)
    Y = ReadJSON(pathY)
    
    X, Y = remove_signatures(X, Y)
    unique, f_len =  high_level_features(X)
    info = get_features_info(X, Y)
    
    #Analysing & Visualizing All Data Features
    features_count = info['features_count']
    count = list(features_count.values())
    dist, dist_size = get_distribution(count)
    labels = list(dist.keys())
    pie_plot(dist_size, labels, title='All Data Features Appearance Distribution', 
             title2='Distibutions')
    
    #Distribution of Features Classwise e.g: Benignware, Malware, Common
    g_ware_only = info['benignware_feature_only'] 
    m_ware_only = info['malware_feature_only']
    cmn_features = info['common_features']
    labels = ['Features of Benignware Only', 'Features of Malware Only', 'Common Features in Both']
    data = [len(g_ware_only), len(m_ware_only), len(cmn_features)]
    t_fe = str(sum(data))
    pie_plot(data, labels, title='Class Wise Features Distributions - '+t_fe, title2='Classes', r=1)
    
    #Analysis of Categories & Visualization
    catogeories_count = info['catogeories_count']
    g_ware = []
    m_ware = []
    labels = list(catogeories_count.keys())
    for v in list(catogeories_count.values()):
        g_ware.append(v[0])
        m_ware.append(v[1])
    lb = ['Benignware', 'Malware']
    title = 'Class Distribution of Categories'
    y_label = 'Number of Features'
    grouped_bar_plot(g_ware, m_ware, labels, lb, title, y_label)
    
    #################################################
    Y = np.array(Y)
    indicies_malware = np.where(Y == 1)[0]
    indicies_benignware = np.where(Y == 0)[0]
    data = [len(indicies_benignware), len(indicies_malware)]
    labels = ['Benignware', 'Malware']
    title = 'Dataset Summary - Total Samples - '+str(sum(data))
    title2 = 'Classes'
    pie_plot(data, labels, title, title2, r=1.0, fmt='my_fmt')
    
    ############# Mean Anaylsis #############
    #Array containg number of features of each sample
    f_len_ar = np.array(f_len)
    #getting number features for each sample for Benignware
    g_ware_f_len = f_len_ar[list(indicies_benignware)]
    #getting number features for each sample for Malware
    m_ware_f_len = f_len_ar[list(indicies_malware)]
    #Generating the column names for DF
    col1 = fil(len(f_len_ar), 'All Data')
    col2 = fil(len(g_ware_f_len), 'Benignware')
    col3 = fil(len(m_ware_f_len), 'Malware')
    
    #Computing Stats
    arrays = [f_len_ar, g_ware_f_len, m_ware_f_len]
    classes = ['AllData', 'Benignware', 'Malware']
    means, mins, maxes, std = compute_stats(arrays, classes)
        
    
    #concatenating data
    data = np.concatenate((f_len_ar, g_ware_f_len, m_ware_f_len))
    cols = col1 + col2 + col3
    #generating df
    df = pd.DataFrame({'Features':data, 'Class':cols})
    #Plotting Box Plot for Data Features Summary
    title = 'Features Summary'
    get_box_plot(data, title)


