# -*- coding: utf-8 -*-
"""
Created on Wed Sep  2 17:43:44 2020

@author: Danish
"""


import json
from tqdm import tqdm
import numpy as np
from DataPrepration import remove_signatures
import matplotlib.pyplot as plt



def ReadJSON(path):
    with open(path, 'r') as f:
        obj = json.load(f)
    return obj


def high_level_features(X):    
    f_len = []
    unique = []    
    for i in tqdm(X):
        f_len.append(len(i))
        for f in list(i.keys()):
            if f.split(':')[0] not in unique:
                unique.append(f.split(':')[0])
    return unique, f_len

def non_common(dic1, dic2, common=False):
    dic3 = {}
    if not common:
        for f in dic1:
            if f not in dic2: 
                dic3[f] = dic1[f]
    elif common:
        for f in dic1:
            if f in dic2: 
                dic3[f] = dic1[f]
    return dic3

def get_features_info(X, Y):
    info = {}
    features_count = {}
    malware_feature_count = {}
    goodware_feature_count = {}
    catogeories_count = {}
    for val in unique:
        #[Goodware, Malware]
        catogeories_count[val] = [0, 0]
        
    for idx, dic in tqdm(enumerate(X)):
        label = Y[idx]
        for f in dic:
            #finding category
            category = f.split(':')[0]
            #categories count
            catogeories_count[category][label] += 1
            #Counting features
            if f not in features_count:
                features_count[f] = 1
            else:
                features_count[f] += 1
            #Goodware Count
            if label==0:
                if f not in goodware_feature_count:
                    goodware_feature_count[f] = 1
                else:
                    goodware_feature_count[f] += 1 
            #Malware Count
            if label==1:
                if f not in malware_feature_count:
                    malware_feature_count[f] = 1
                else:
                    malware_feature_count[f] += 1
    goodware_feature_only = non_common(goodware_feature_count, malware_feature_count)  
    malware_feature_only = non_common(malware_feature_count, goodware_feature_count)       
    common_features = non_common(goodware_feature_count, malware_feature_count, common=True)    
    
    info['features_count'] = features_count
    info['malware_feature_count'] = malware_feature_count
    info['goodware_feature_count'] = goodware_feature_count
    info['catogeories_count'] = catogeories_count
    info['goodware_feature_only'] = goodware_feature_only
    info['malware_feature_only'] = malware_feature_only
    info['common_features'] = common_features
    return info

def get_distribution(count):
    max_val = str(max(count))
    dist = {'1':[], '2-10':[], '11-100':[], '101-'+max_val:[]}
    for val in count:
        if val==1:
            dist['1'].append(val)
        elif val>=2 and val<=10:
            dist['2-10'].append(val)
        elif val>10 and val<=100:
            dist['11-100'].append(val)
        else:
            dist['101-'+max_val].append(val)
            dist_size = []
    for v in list(dist.values()):
        dist_size.append(len(v))
    return dist, dist_size

def pie_plot(data, labels, title, title2, r=1.2, save=True):
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    ax.axis('equal')
    wedges, texts, autotexts = ax.pie(data, labels=labels, autopct='%1.1f%%',
                                      radius=r, pctdistance=0.85)
    ax.legend(wedges, labels, title=title2, loc="upper left",
              bbox_to_anchor=(1, 0, 0.5, 1))
    plt.setp(autotexts, size=8, weight="bold")
    ax.set_title(title, loc='left')
    if save:
        plt.savefig(title+'.png', bbox_inches='tight', dpi=300)
    plt.show()
    plt.close()

pathX = 'drebin-features/drebin-parrot-v2-down-features-X.json'
pathY = 'drebin-features/drebin-parrot-v2-down-features-Y.json'
#Read Data
X = ReadJSON(pathX)
Y = ReadJSON(pathY)

X, Y = remove_signatures(X, Y)
unique, f_len =  high_level_features(X)
info = get_features_info(X, Y)

#Analysing & Visualizing All Data Features
features_count = info['features_count']
count = list(features_count.values())
dist, dist_size = get_distribution(count)
labels = list(dist.keys())
pie_plot(dist_size, labels, title='All Data Features Appearance Distribution', 
         title2='Distibutions')

#Distribution of Features Classwise e.g: Goodware, Malware, Common
g_ware_only = info['goodware_feature_only'] 
m_ware_only = info['malware_feature_only']
cmn_features = info['common_features']
labels = ['Features of Goodware Only', 'Features of Malware Only', 'Common Features in Both']
data = [len(g_ware_only), len(m_ware_only), len(cmn_features)]
t_fe = str(sum(data))
pie_plot(data, labels, title='Class Wise Features Distributions - '+t_fe, title2='Classes', r=1)

#Analysis of Categories & Visualization
catogeories_count = info['catogeories_count']
g_ware = []
m_ware = []
labels = list(catogeories_count.keys())
for v in list(catogeories_count.values()):
    g_ware.append(v[0])
    m_ware.append(v[1])
lb = ['Goodware', 'Malware']
title = 'Class Distribution of Categories'
y_label = 'Number of Features'
grouped_bar_plot(g_ware, m_ware, labels, lb, title, y_label)

def grouped_bar_plot(d1, d2, labels, lb, title, y_label, save=True):
    x = np.arange(len(labels))  # the label locations
    width = 0.35  # the width of the bars
    fig, ax = plt.subplots()
    rects1 = ax.bar(x - width/2, d1, width, label=lb[0])
    rects2 = ax.bar(x + width/2, d2, width, label=lb[1])
    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_ylabel(y_label)
    ax.set_title(title)
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(labels), rotation=45, ha="right",
             rotation_mode="anchor")
    ax.legend()
    def autolabel(rects):
        """Attach a text label above each bar in *rects*, displaying its height."""
        for rect in rects:
            height = rect.get_height()
            ax.annotate('{}'.format(height),
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom')
    autolabel(rects1)
    autolabel(rects2)
    fig.tight_layout()
    if save:
        plt.savefig(title+'.png', bbox_inches='tight', dpi=300)
    plt.show()
    plt.close()