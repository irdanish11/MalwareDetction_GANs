# -*- coding: utf-8 -*-
"""
Created on Thu Sep  3 17:05:23 2020

@author: Danish
"""


import time
import sys
import tensorflow as tf
import os
import json

def ToJson(obj, name, path='./', json_dir=False):
    """ Write the Given Object to JSON file on the given path and name.
        
        Arguments:
        ----------
        obj: The object/variable you want to write to JSON file, it can be list or dictionary.
        
        name: Name for the JSON file.
        
        path: Path in which you want to save the JSON file. If want to save the JSON file in the current
        directory, do not specify the value of this argument.
              
        json_dir: Boolean value if set to `True` a new directory with the name of `JSON` will be added at
        the end of the given path.
                  
        Returns:
        --------
        None"""
    if json_dir:
        os.makedirs(path+'/JSON', exist_ok=True)
        with open(path+'/JSON/{0}.json'.format(name), 'w') as f:
            json.dump(obj, f)
        f.close()
    elif not json_dir:
        if '.json' in name:
            pass
        else:
            name=name+'.json'
        with open(path+'/'+name, 'w') as f:
            json.dump(obj, f)
        f.close()

class Timer:
    def __init__(self):
        self.begin = 0
        self.total_time=0
    def restart(self):
        self.begin = time.time()
    def start(self):
        self.begin = time.time()
    def time_converter(self, time):
        m, s = divmod(time, 60)
        h, m = divmod(m, 60)
        return "%02d:%02d:%02d" % (h, m, s)
    
    def get_time_hhmmss(self, rem_batches):
        end = time.time()
        time_taken = end - self.begin
        reamin_time = time_taken*rem_batches
        time_str = self.time_converter(reamin_time)
        self.total_time += time_taken
        return time_str, time_taken
    def get_total_time(self):
        return self.time_converter(self.total_time)
    
#some utility methods    
def PrintInline(string):
    sys.stdout.write('\r'+string)
    sys.stdout.flush() 
    
def TF_GPUsetup(GB=4):
    """
    Restrict TensorFlow to only allocate 1*X GB of memory on the first GPU. Often Needed
    When GPU run out of memory. It would be one of the solution for the issue: Failed to 
    get convolution algorithm. This is probably because cuDNN failed to initialize,

    Parameters
    ----------
    GB : int, optional
        The amount of GPU memory you want to use. It is recommended to use  1 GB
        less than your total GPU memory. The default is 4.

    Returns
    -------
    None.

    """
    if type(GB)!=int:
        raise TypeError('Type of Parameter `GB` must be `int` and it should be 1 GB less than your GPU memory')
    gpus = tf.config.experimental.list_physical_devices('GPU')
    config = [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=(1024*GB))]
    if gpus:
      # Restrict TensorFlow to only allocate 1*X GB of memory on the first GPU
      try:
        tf.config.experimental.set_virtual_device_configuration(gpus[0], config)
        logical_gpus = tf.config.experimental.list_logical_devices('GPU')
        print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPUs")
      except RuntimeError as e:
        # Virtual devices must be set before GPUs have been initialized
        print(e)
    print('\nTensorflow GPU installed: '+str(tf.test.is_built_with_cuda()))
    print('Is Tensorflow using GPU: '+str(tf.test.is_gpu_available()))
    
def info_out(which, history, timers=None, epoch=None, epochs=None, batch=None, steps_per_epoch=None, total_time=None):
    history_batch = history[0]; history_epoch = history[1]
    if which.lower()=='batch':
        time_remain = timers[0]; time_taken = timers[1]
        str1 =  'Epoch {0}/{1}, Batch {2}/{3}, - '.format(epoch, epochs, batch, steps_per_epoch-1)
        str2 = 'Time Taken By 1 Batch: {0:.2} sec. -      Est Time Remaining: {1}, - '.format(time_taken, time_remain)
        str3 = '  Discriminator Loss: {0:.5}, - Discriminator Accuracy: {1:.5} - '.format(history_batch['Disc_Loss'][batch-1], 
                                                                                        history_batch['Disc_Acc'][batch-1])
        str4 = '  Generator Loss: {0:.5}, - Generator Accuracy: {1:.3}.'.format(history_batch['Gen_Loss'][batch-1], 
                                                                              history_batch['Gen_Acc'][batch-1])
        PrintInline(str1+str2+str3+str4)
    elif which.lower()=='epoch':
        str1 = 'Discriminator Loss: {0:.5}, - Discriminator Accuracy: {1:.3} - '.format(history_epoch['Disc_Loss'][epoch-1], 
                                                                                        history_epoch['Disc_Acc'][epoch-1])
        str2 = 'Generator Loss: {0:.5}, - Generator Accuracy: {1:.3}.'.format(history_epoch['Gen_Loss'][epoch-1], 
                                                                              history_epoch['Gen_Acc'][epoch-1])
        print('\nEpoch Completed, Total Time Taken: ' + total_time + ', - ' + str1 + str2)
        print('\t\t\t________________________________________________________\n')
    else:
        raise ValueError('Invalid value given to `which`, it can be either `batch` or `epoch`!')
    
class Callbacks:
    def __init__(self, ckpt_path, models, metric_disc='loss', metric_gen='loss', save_best_only=True): 
        self.ckpt_path = ckpt_path
        self.models = models
        self.metric_disc = metric_disc
        self.metric_gen = metric_gen
        self.save_best_only = save_best_only
        self.disc_metric = None
        self.gen_metric = None
        
    def ckpt_callback(self, epoch, history_epoch):
        #intializing variables
        path = self.ckpt_path
        models = self.models
        metric_disc = self.metric_disc
        metric_gen = self.metric_gen
        save_best_only = self.save_best_only
        
        #reinforcing constraints
        if type(models)!= list:
            raise TypeError('Invalid value given to models it should be a list containing three models in this order: [generator, discriminator, gan_model]')
        os.makedirs(path, exist_ok=True)
        def save_disc(models, path):
            models[1].save(path+'/Discriminator.h5')
        def save_gen(models, path):
            models[0].save(path+'/Generator.h5')
            models[2].save(path+'/GAN_Model.h5')
            
        if save_best_only:
            #intializaing metric value
            if metric_disc=='loss' and metric_gen=='loss':
                if epoch==1:
                    self.disc_metric = 1000.0
                    self.gen_metric = 1000.0
                #Checking for improvements
                if history_epoch['Disc_Loss'][epoch-1] < self.disc_metric:
                    save_disc(models, path)
                if history_epoch['Gen_Loss'][epoch-1] < self.gen_metric:
                    save_gen(models, path)
                    
            elif metric_disc=='accuracy' and metric_gen=='accuracy':
                if epoch==1:
                    self.disc_metric = 0.0
                    self.gen_metric = 0.0
                #Checking for improvements
                if history_epoch['Disc_Acc'][epoch-1] > self.disc_metric:
                    save_disc(models, path)
                if history_epoch['Gen_Acc'][epoch-1] > self.gen_metric:
                    save_gen(models, path)
                    
            elif metric_disc=='loss' and metric_gen=='accuracy':
                if epoch==1:
                    self.disc_metric = 1000.0
                    self.gen_metric = 0.0
                #Checking for improvements
                if history_epoch['Disc_Loss'][epoch-1] < self.disc_metric:
                    save_disc(models, path)
                if history_epoch['Gen_Acc'][epoch-1] < self.gen_metric:
                    save_gen(models, path)
                    
            elif metric_disc=='accuracy' and metric_gen=='loss':
                if epoch==1:
                    self.disc_metric = 0.0
                    self.gen_metric = 1000.0
                #Checking for improvements
                if history_epoch['Disc_Acc'][epoch-1] < self.disc_metric:
                    save_disc(models, path)
                if history_epoch['Gen_Loss'][epoch-1] < self.gen_metric:
                    save_gen(models, path)
                    
            elif metric_disc==None and metric_gen=='loss':
                if epoch==1:
                    self.gen_metric = 1000.0
                #Checking for improvements
                if history_epoch['Gen_Loss'][epoch-1] < self.gen_metric:
                    save_gen(models, path) 
        else:
            save_disc(models, path)
            save_gen(models, path)

            